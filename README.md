# Y86-64 处理器模拟器项目文档

## 1\. 项目概述

本项目旨在设计并实现一个基于 Y86-64 指令集架构（ISA）的软件模拟器。Y86-64 是一种受 x86-64 启发的简化指令集，广泛应用于计算机体系结构教学中，特别是卡内基梅隆大学的《深入理解计算机系统》（CSAPP）课程。

本模拟器不仅完整实现了 Y86-64 的顺序执行模型（SEQ），还扩展了存储层次结构，引入了高速缓存（Cache）模拟机制，并配备了图形化用户界面（GUI）以支持可视化的程序调试与状态监控。

## 2\. 系统架构

本系统由核心模拟引擎（后端）与可视化界面（前端）两部分组成。

### 2.1 核心模拟引擎 (C++)

核心引擎负责解释执行 Y86-64 机器码。处理器状态采用类 `Simulator` 封装，模拟了以下硬件组件：

  * **程序计数器 (PC)**：64位寄存器，存储当前指令地址。
  * **寄存器文件 (Register File)**：包含 15 个 64 位通用寄存器（%rax 至 %r14）。
  * **条件码 (Condition Codes)**：ZF（零标志）、SF（符号标志）、OF（溢出标志），用于逻辑控制流。
  * **状态码 (Stat)**：指示处理器当前状态（AOK、HLT、ADR、INS）。
  * **主存储器 (Main Memory)**：模拟 64KB 的字节寻址存储空间。

指令执行周期遵循标准的六阶段设计：

1.  **取指 (Fetch)**：从内存读取指令字节，计算下一条指令地址 (valP)。
2.  **译码 (Decode)**：从寄存器文件读取操作数 (valA, valB)。
3.  **执行 (Execute)**：ALU 执行算术逻辑运算或计算内存有效地址 (valE)，并设置条件码。
4.  **访存 (Memory)**：读写数据存储器 (valM)。
5.  **写回 (Write-back)**：将结果写回寄存器文件。
6.  **更新 PC (PC Update)**：更新程序计数器指向下一条指令。

### 2.2 存储层次结构模拟 (Cache)

为了模拟真实计算机系统的局部性原理，本项目在 CPU 与主存之间实现了一个软件模拟的 **L1 高速缓存**。

  * **映射策略**：直接映射 (Direct Mapped)。
  * **配置参数**：
      * 缓存组数 (Sets)：16 组。
      * 块大小 (Block Size)：32 字节。
  * **写策略**：采用 **直写 (Write-Through)** 结合 **写分配 (Write-Allocate)** 策略，确保主存与缓存的数据一致性，同时利用空间局部性优化连续写入性能。
  * **替换策略**：由于采用直接映射，发生冲突时直接替换对应行的块。

### 2.3 可视化前端 (Python/Tkinter)

前端通过 Python 的 Tkinter 库实现，通过标准输入输出流与 C++ 后端通信。

  * **交互模式**：支持加载 `.yo` 目标文件，提供单步执行（Step Over/Back）功能。
  * **状态展示**：
      * **寄存器堆**：实时显示 15 个通用寄存器的十六进制值，并对发生变化的寄存器进行高亮提示。
      * **源代码映射**：解析 `.yo` 文件，将当前 PC 映射到对应的汇编源代码行并高亮显示。
      * **内存视图**：以表格形式展示非零内存区域的数据。
      * **缓存统计**：实时显示 Cache 的命中数 (Hits)、未命中数 (Misses) 及命中率 (Hit Rate)。

## 3\. 实现细节

### 3.1 内存读写接口

底层内存访问被封装为 `readLong` 和 `writeLong` 接口。这些接口拦截了所有对物理内存的请求，优先通过 `readByteCached` 和 `writeByteCached` 访问模拟的 Cache 层。只有在 Cache 未命中（Miss）时，才会触发块加载（Block Loading）操作，从主存搬运数据块至 Cache。

### 3.2 异常处理

模拟器具备完善的异常检测机制：

  * **INS (Invalid Instruction)**：检测到未定义的指令编码。
  * **ADR (Invalid Address)**：检测到访问越界或非法内存地址。
  * **HLT (Halt)**：正确处理停机指令。

### 3.3 数据交换格式

后端与前端通过 JSON 格式交换数据。C++ 后端引入 `nlohmann/json` 库，在每条指令执行结束后，将当前的 PC、寄存器值、条件码、非零内存及缓存统计数据序列化为 JSON 对象输出到标准输出流。

## 4\. 验证与测试

项目包含完整的自动化回归测试套件 (`test.py`)，用于验证模拟器的正确性。

  * **测试用例**：覆盖了算术运算、数据传送、栈操作、函数调用/返回、条件跳转及各类数据冒险场景（如 `test/asum.yo`, `test/prog1.yo` 等）。
  * **验证方法**：测试脚本将模拟器的输出状态与预设的“标准答案”（Golden Standard，位于 `answer/` 目录）进行逐字段比对。
  * **测试结果**：模拟器通过了所有提供的基准测试用例，且缓存模拟逻辑在顺序访问测试中表现出了预期的命中率提升。

## 5\. 编译与运行指南

### 5.1 环境要求

  * C++ 编译器 (支持 C++17 标准，如 GCC 或 Clang)
  * Python 3.x (包含 Tkinter 库)

### 5.2 编译

使用提供的 Makefile 进行编译：

```bash
make
```

该命令将生成名为 `cpu` (Linux/macOS) 或 `cpu.exe` (Windows) 的可执行文件。

### 5.3 运行自动化测试

执行测试脚本以验证所有测试用例：

```bash
python test.py --bin ./cpu
```

### 5.4 启动可视化界面

运行 Python 图形界面脚本：

```bash
python gui.py
```

在界面中点击 "Load Program" 选择 `test/` 目录下的 `.yo` 文件即可开始可视化模拟。

## 6\. 参考文献

[1] Randal E. Bryant and David R. O'Hallaron. *Computer Systems: A Programmer's Perspective*, 3rd Edition. Pearson, 2015.